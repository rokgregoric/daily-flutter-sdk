// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'streaming.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StreamId {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StreamIdCopyWith<StreamId> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamIdCopyWith<$Res> {
  factory $StreamIdCopyWith(StreamId value, $Res Function(StreamId) then) =
      _$StreamIdCopyWithImpl<$Res, StreamId>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class _$StreamIdCopyWithImpl<$Res, $Val extends StreamId>
    implements $StreamIdCopyWith<$Res> {
  _$StreamIdCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StreamIdImplCopyWith<$Res>
    implements $StreamIdCopyWith<$Res> {
  factory _$$StreamIdImplCopyWith(
          _$StreamIdImpl value, $Res Function(_$StreamIdImpl) then) =
      __$$StreamIdImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$StreamIdImplCopyWithImpl<$Res>
    extends _$StreamIdCopyWithImpl<$Res, _$StreamIdImpl>
    implements _$$StreamIdImplCopyWith<$Res> {
  __$$StreamIdImplCopyWithImpl(
      _$StreamIdImpl _value, $Res Function(_$StreamIdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$StreamIdImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$StreamIdImpl extends _StreamId {
  const _$StreamIdImpl(this.id) : super._();

  @override
  final String id;

  @override
  String toString() {
    return 'StreamId(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamIdImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamIdImplCopyWith<_$StreamIdImpl> get copyWith =>
      __$$StreamIdImplCopyWithImpl<_$StreamIdImpl>(this, _$identity);
}

abstract class _StreamId extends StreamId {
  const factory _StreamId(final String id) = _$StreamIdImpl;
  const _StreamId._() : super._();

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  _$$StreamIdImplCopyWith<_$StreamIdImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecordingId {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RecordingIdCopyWith<RecordingId> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecordingIdCopyWith<$Res> {
  factory $RecordingIdCopyWith(
          RecordingId value, $Res Function(RecordingId) then) =
      _$RecordingIdCopyWithImpl<$Res, RecordingId>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class _$RecordingIdCopyWithImpl<$Res, $Val extends RecordingId>
    implements $RecordingIdCopyWith<$Res> {
  _$RecordingIdCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RecordingIdImplCopyWith<$Res>
    implements $RecordingIdCopyWith<$Res> {
  factory _$$RecordingIdImplCopyWith(
          _$RecordingIdImpl value, $Res Function(_$RecordingIdImpl) then) =
      __$$RecordingIdImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$RecordingIdImplCopyWithImpl<$Res>
    extends _$RecordingIdCopyWithImpl<$Res, _$RecordingIdImpl>
    implements _$$RecordingIdImplCopyWith<$Res> {
  __$$RecordingIdImplCopyWithImpl(
      _$RecordingIdImpl _value, $Res Function(_$RecordingIdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$RecordingIdImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RecordingIdImpl extends _RecordingId {
  const _$RecordingIdImpl(this.id) : super._();

  @override
  final String id;

  @override
  String toString() {
    return 'RecordingId(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordingIdImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordingIdImplCopyWith<_$RecordingIdImpl> get copyWith =>
      __$$RecordingIdImplCopyWithImpl<_$RecordingIdImpl>(this, _$identity);
}

abstract class _RecordingId extends RecordingId {
  const factory _RecordingId(final String id) = _$RecordingIdImpl;
  const _RecordingId._() : super._();

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  _$$RecordingIdImplCopyWith<_$RecordingIdImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StreamingSettings _$StreamingSettingsFromJson(Map<String, dynamic> json) {
  return _StreamingSettings.fromJson(json);
}

/// @nodoc
mixin _$StreamingSettings {
  StreamingVideoSettings? get video => throw _privateConstructorUsedError;
  StreamingAudioSettings? get audio => throw _privateConstructorUsedError;
  StreamingLayout? get layout => throw _privateConstructorUsedError;
  int? get maxDuration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StreamingSettingsCopyWith<StreamingSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamingSettingsCopyWith<$Res> {
  factory $StreamingSettingsCopyWith(
          StreamingSettings value, $Res Function(StreamingSettings) then) =
      _$StreamingSettingsCopyWithImpl<$Res, StreamingSettings>;
  @useResult
  $Res call(
      {StreamingVideoSettings? video,
      StreamingAudioSettings? audio,
      StreamingLayout? layout,
      int? maxDuration});

  $StreamingVideoSettingsCopyWith<$Res>? get video;
  $StreamingAudioSettingsCopyWith<$Res>? get audio;
  $StreamingLayoutCopyWith<$Res>? get layout;
}

/// @nodoc
class _$StreamingSettingsCopyWithImpl<$Res, $Val extends StreamingSettings>
    implements $StreamingSettingsCopyWith<$Res> {
  _$StreamingSettingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? video = freezed,
    Object? audio = freezed,
    Object? layout = freezed,
    Object? maxDuration = freezed,
  }) {
    return _then(_value.copyWith(
      video: freezed == video
          ? _value.video
          : video // ignore: cast_nullable_to_non_nullable
              as StreamingVideoSettings?,
      audio: freezed == audio
          ? _value.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as StreamingAudioSettings?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      maxDuration: freezed == maxDuration
          ? _value.maxDuration
          : maxDuration // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingVideoSettingsCopyWith<$Res>? get video {
    if (_value.video == null) {
      return null;
    }

    return $StreamingVideoSettingsCopyWith<$Res>(_value.video!, (value) {
      return _then(_value.copyWith(video: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingAudioSettingsCopyWith<$Res>? get audio {
    if (_value.audio == null) {
      return null;
    }

    return $StreamingAudioSettingsCopyWith<$Res>(_value.audio!, (value) {
      return _then(_value.copyWith(audio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingLayoutCopyWith<$Res>? get layout {
    if (_value.layout == null) {
      return null;
    }

    return $StreamingLayoutCopyWith<$Res>(_value.layout!, (value) {
      return _then(_value.copyWith(layout: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$StreamingSettingsImplCopyWith<$Res>
    implements $StreamingSettingsCopyWith<$Res> {
  factory _$$StreamingSettingsImplCopyWith(_$StreamingSettingsImpl value,
          $Res Function(_$StreamingSettingsImpl) then) =
      __$$StreamingSettingsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {StreamingVideoSettings? video,
      StreamingAudioSettings? audio,
      StreamingLayout? layout,
      int? maxDuration});

  @override
  $StreamingVideoSettingsCopyWith<$Res>? get video;
  @override
  $StreamingAudioSettingsCopyWith<$Res>? get audio;
  @override
  $StreamingLayoutCopyWith<$Res>? get layout;
}

/// @nodoc
class __$$StreamingSettingsImplCopyWithImpl<$Res>
    extends _$StreamingSettingsCopyWithImpl<$Res, _$StreamingSettingsImpl>
    implements _$$StreamingSettingsImplCopyWith<$Res> {
  __$$StreamingSettingsImplCopyWithImpl(_$StreamingSettingsImpl _value,
      $Res Function(_$StreamingSettingsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? video = freezed,
    Object? audio = freezed,
    Object? layout = freezed,
    Object? maxDuration = freezed,
  }) {
    return _then(_$StreamingSettingsImpl(
      video: freezed == video
          ? _value.video
          : video // ignore: cast_nullable_to_non_nullable
              as StreamingVideoSettings?,
      audio: freezed == audio
          ? _value.audio
          : audio // ignore: cast_nullable_to_non_nullable
              as StreamingAudioSettings?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      maxDuration: freezed == maxDuration
          ? _value.maxDuration
          : maxDuration // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StreamingSettingsImpl implements _StreamingSettings {
  const _$StreamingSettingsImpl(
      {this.video, this.audio, this.layout, this.maxDuration});

  factory _$StreamingSettingsImpl.fromJson(Map<String, dynamic> json) =>
      _$$StreamingSettingsImplFromJson(json);

  @override
  final StreamingVideoSettings? video;
  @override
  final StreamingAudioSettings? audio;
  @override
  final StreamingLayout? layout;
  @override
  final int? maxDuration;

  @override
  String toString() {
    return 'StreamingSettings(video: $video, audio: $audio, layout: $layout, maxDuration: $maxDuration)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamingSettingsImpl &&
            (identical(other.video, video) || other.video == video) &&
            (identical(other.audio, audio) || other.audio == audio) &&
            (identical(other.layout, layout) || other.layout == layout) &&
            (identical(other.maxDuration, maxDuration) ||
                other.maxDuration == maxDuration));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, video, audio, layout, maxDuration);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamingSettingsImplCopyWith<_$StreamingSettingsImpl> get copyWith =>
      __$$StreamingSettingsImplCopyWithImpl<_$StreamingSettingsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StreamingSettingsImplToJson(
      this,
    );
  }
}

abstract class _StreamingSettings implements StreamingSettings {
  const factory _StreamingSettings(
      {final StreamingVideoSettings? video,
      final StreamingAudioSettings? audio,
      final StreamingLayout? layout,
      final int? maxDuration}) = _$StreamingSettingsImpl;

  factory _StreamingSettings.fromJson(Map<String, dynamic> json) =
      _$StreamingSettingsImpl.fromJson;

  @override
  StreamingVideoSettings? get video;
  @override
  StreamingAudioSettings? get audio;
  @override
  StreamingLayout? get layout;
  @override
  int? get maxDuration;
  @override
  @JsonKey(ignore: true)
  _$$StreamingSettingsImplCopyWith<_$StreamingSettingsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StreamingSettingsUpdate {
  StreamingLayout? get layout => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StreamingLayout? layout) set,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StreamingLayout? layout)? set,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StreamingLayout? layout)? set,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StreamingSettingsUpdate value) set,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StreamingSettingsUpdate value)? set,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StreamingSettingsUpdate value)? set,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StreamingSettingsUpdateCopyWith<StreamingSettingsUpdate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamingSettingsUpdateCopyWith<$Res> {
  factory $StreamingSettingsUpdateCopyWith(StreamingSettingsUpdate value,
          $Res Function(StreamingSettingsUpdate) then) =
      _$StreamingSettingsUpdateCopyWithImpl<$Res, StreamingSettingsUpdate>;
  @useResult
  $Res call({StreamingLayout? layout});

  $StreamingLayoutCopyWith<$Res>? get layout;
}

/// @nodoc
class _$StreamingSettingsUpdateCopyWithImpl<$Res,
        $Val extends StreamingSettingsUpdate>
    implements $StreamingSettingsUpdateCopyWith<$Res> {
  _$StreamingSettingsUpdateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? layout = freezed,
  }) {
    return _then(_value.copyWith(
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingLayoutCopyWith<$Res>? get layout {
    if (_value.layout == null) {
      return null;
    }

    return $StreamingLayoutCopyWith<$Res>(_value.layout!, (value) {
      return _then(_value.copyWith(layout: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$StreamingSettingsUpdateImplCopyWith<$Res>
    implements $StreamingSettingsUpdateCopyWith<$Res> {
  factory _$$StreamingSettingsUpdateImplCopyWith(
          _$StreamingSettingsUpdateImpl value,
          $Res Function(_$StreamingSettingsUpdateImpl) then) =
      __$$StreamingSettingsUpdateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({StreamingLayout? layout});

  @override
  $StreamingLayoutCopyWith<$Res>? get layout;
}

/// @nodoc
class __$$StreamingSettingsUpdateImplCopyWithImpl<$Res>
    extends _$StreamingSettingsUpdateCopyWithImpl<$Res,
        _$StreamingSettingsUpdateImpl>
    implements _$$StreamingSettingsUpdateImplCopyWith<$Res> {
  __$$StreamingSettingsUpdateImplCopyWithImpl(
      _$StreamingSettingsUpdateImpl _value,
      $Res Function(_$StreamingSettingsUpdateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? layout = freezed,
  }) {
    return _then(_$StreamingSettingsUpdateImpl(
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
    ));
  }
}

/// @nodoc
@JsonSerializable(createFactory: false)
class _$StreamingSettingsUpdateImpl implements _StreamingSettingsUpdate {
  const _$StreamingSettingsUpdateImpl({this.layout});

  @override
  final StreamingLayout? layout;

  @override
  String toString() {
    return 'StreamingSettingsUpdate.set(layout: $layout)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamingSettingsUpdateImpl &&
            (identical(other.layout, layout) || other.layout == layout));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, layout);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamingSettingsUpdateImplCopyWith<_$StreamingSettingsUpdateImpl>
      get copyWith => __$$StreamingSettingsUpdateImplCopyWithImpl<
          _$StreamingSettingsUpdateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(StreamingLayout? layout) set,
  }) {
    return set(layout);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(StreamingLayout? layout)? set,
  }) {
    return set?.call(layout);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(StreamingLayout? layout)? set,
    required TResult orElse(),
  }) {
    if (set != null) {
      return set(layout);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StreamingSettingsUpdate value) set,
  }) {
    return set(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StreamingSettingsUpdate value)? set,
  }) {
    return set?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StreamingSettingsUpdate value)? set,
    required TResult orElse(),
  }) {
    if (set != null) {
      return set(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$StreamingSettingsUpdateImplToJson(
      this,
    );
  }
}

abstract class _StreamingSettingsUpdate implements StreamingSettingsUpdate {
  const factory _StreamingSettingsUpdate({final StreamingLayout? layout}) =
      _$StreamingSettingsUpdateImpl;

  @override
  StreamingLayout? get layout;
  @override
  @JsonKey(ignore: true)
  _$$StreamingSettingsUpdateImplCopyWith<_$StreamingSettingsUpdateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StreamingVideoSettings _$StreamingVideoSettingsFromJson(
    Map<String, dynamic> json) {
  return _StreamingVideoSettings.fromJson(json);
}

/// @nodoc
mixin _$StreamingVideoSettings {
  int? get width => throw _privateConstructorUsedError;
  int? get height => throw _privateConstructorUsedError;
  int? get fps => throw _privateConstructorUsedError;
  int? get bitrate => throw _privateConstructorUsedError;
  String? get backgroundColor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StreamingVideoSettingsCopyWith<StreamingVideoSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamingVideoSettingsCopyWith<$Res> {
  factory $StreamingVideoSettingsCopyWith(StreamingVideoSettings value,
          $Res Function(StreamingVideoSettings) then) =
      _$StreamingVideoSettingsCopyWithImpl<$Res, StreamingVideoSettings>;
  @useResult
  $Res call(
      {int? width,
      int? height,
      int? fps,
      int? bitrate,
      String? backgroundColor});
}

/// @nodoc
class _$StreamingVideoSettingsCopyWithImpl<$Res,
        $Val extends StreamingVideoSettings>
    implements $StreamingVideoSettingsCopyWith<$Res> {
  _$StreamingVideoSettingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? fps = freezed,
    Object? bitrate = freezed,
    Object? backgroundColor = freezed,
  }) {
    return _then(_value.copyWith(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      fps: freezed == fps
          ? _value.fps
          : fps // ignore: cast_nullable_to_non_nullable
              as int?,
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      backgroundColor: freezed == backgroundColor
          ? _value.backgroundColor
          : backgroundColor // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StreamingVideoSettingsImplCopyWith<$Res>
    implements $StreamingVideoSettingsCopyWith<$Res> {
  factory _$$StreamingVideoSettingsImplCopyWith(
          _$StreamingVideoSettingsImpl value,
          $Res Function(_$StreamingVideoSettingsImpl) then) =
      __$$StreamingVideoSettingsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? width,
      int? height,
      int? fps,
      int? bitrate,
      String? backgroundColor});
}

/// @nodoc
class __$$StreamingVideoSettingsImplCopyWithImpl<$Res>
    extends _$StreamingVideoSettingsCopyWithImpl<$Res,
        _$StreamingVideoSettingsImpl>
    implements _$$StreamingVideoSettingsImplCopyWith<$Res> {
  __$$StreamingVideoSettingsImplCopyWithImpl(
      _$StreamingVideoSettingsImpl _value,
      $Res Function(_$StreamingVideoSettingsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? fps = freezed,
    Object? bitrate = freezed,
    Object? backgroundColor = freezed,
  }) {
    return _then(_$StreamingVideoSettingsImpl(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      fps: freezed == fps
          ? _value.fps
          : fps // ignore: cast_nullable_to_non_nullable
              as int?,
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      backgroundColor: freezed == backgroundColor
          ? _value.backgroundColor
          : backgroundColor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StreamingVideoSettingsImpl implements _StreamingVideoSettings {
  const _$StreamingVideoSettingsImpl(
      {this.width, this.height, this.fps, this.bitrate, this.backgroundColor});

  factory _$StreamingVideoSettingsImpl.fromJson(Map<String, dynamic> json) =>
      _$$StreamingVideoSettingsImplFromJson(json);

  @override
  final int? width;
  @override
  final int? height;
  @override
  final int? fps;
  @override
  final int? bitrate;
  @override
  final String? backgroundColor;

  @override
  String toString() {
    return 'StreamingVideoSettings(width: $width, height: $height, fps: $fps, bitrate: $bitrate, backgroundColor: $backgroundColor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamingVideoSettingsImpl &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.fps, fps) || other.fps == fps) &&
            (identical(other.bitrate, bitrate) || other.bitrate == bitrate) &&
            (identical(other.backgroundColor, backgroundColor) ||
                other.backgroundColor == backgroundColor));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, width, height, fps, bitrate, backgroundColor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamingVideoSettingsImplCopyWith<_$StreamingVideoSettingsImpl>
      get copyWith => __$$StreamingVideoSettingsImplCopyWithImpl<
          _$StreamingVideoSettingsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StreamingVideoSettingsImplToJson(
      this,
    );
  }
}

abstract class _StreamingVideoSettings implements StreamingVideoSettings {
  const factory _StreamingVideoSettings(
      {final int? width,
      final int? height,
      final int? fps,
      final int? bitrate,
      final String? backgroundColor}) = _$StreamingVideoSettingsImpl;

  factory _StreamingVideoSettings.fromJson(Map<String, dynamic> json) =
      _$StreamingVideoSettingsImpl.fromJson;

  @override
  int? get width;
  @override
  int? get height;
  @override
  int? get fps;
  @override
  int? get bitrate;
  @override
  String? get backgroundColor;
  @override
  @JsonKey(ignore: true)
  _$$StreamingVideoSettingsImplCopyWith<_$StreamingVideoSettingsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StreamingAudioSettings _$StreamingAudioSettingsFromJson(
    Map<String, dynamic> json) {
  return _StreamingAudioSettings.fromJson(json);
}

/// @nodoc
mixin _$StreamingAudioSettings {
  int? get bitrate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StreamingAudioSettingsCopyWith<StreamingAudioSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamingAudioSettingsCopyWith<$Res> {
  factory $StreamingAudioSettingsCopyWith(StreamingAudioSettings value,
          $Res Function(StreamingAudioSettings) then) =
      _$StreamingAudioSettingsCopyWithImpl<$Res, StreamingAudioSettings>;
  @useResult
  $Res call({int? bitrate});
}

/// @nodoc
class _$StreamingAudioSettingsCopyWithImpl<$Res,
        $Val extends StreamingAudioSettings>
    implements $StreamingAudioSettingsCopyWith<$Res> {
  _$StreamingAudioSettingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bitrate = freezed,
  }) {
    return _then(_value.copyWith(
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StreamingAudioSettingsImplCopyWith<$Res>
    implements $StreamingAudioSettingsCopyWith<$Res> {
  factory _$$StreamingAudioSettingsImplCopyWith(
          _$StreamingAudioSettingsImpl value,
          $Res Function(_$StreamingAudioSettingsImpl) then) =
      __$$StreamingAudioSettingsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? bitrate});
}

/// @nodoc
class __$$StreamingAudioSettingsImplCopyWithImpl<$Res>
    extends _$StreamingAudioSettingsCopyWithImpl<$Res,
        _$StreamingAudioSettingsImpl>
    implements _$$StreamingAudioSettingsImplCopyWith<$Res> {
  __$$StreamingAudioSettingsImplCopyWithImpl(
      _$StreamingAudioSettingsImpl _value,
      $Res Function(_$StreamingAudioSettingsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bitrate = freezed,
  }) {
    return _then(_$StreamingAudioSettingsImpl(
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StreamingAudioSettingsImpl implements _StreamingAudioSettings {
  const _$StreamingAudioSettingsImpl({this.bitrate});

  factory _$StreamingAudioSettingsImpl.fromJson(Map<String, dynamic> json) =>
      _$$StreamingAudioSettingsImplFromJson(json);

  @override
  final int? bitrate;

  @override
  String toString() {
    return 'StreamingAudioSettings(bitrate: $bitrate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamingAudioSettingsImpl &&
            (identical(other.bitrate, bitrate) || other.bitrate == bitrate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, bitrate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamingAudioSettingsImplCopyWith<_$StreamingAudioSettingsImpl>
      get copyWith => __$$StreamingAudioSettingsImplCopyWithImpl<
          _$StreamingAudioSettingsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StreamingAudioSettingsImplToJson(
      this,
    );
  }
}

abstract class _StreamingAudioSettings implements StreamingAudioSettings {
  const factory _StreamingAudioSettings({final int? bitrate}) =
      _$StreamingAudioSettingsImpl;

  factory _StreamingAudioSettings.fromJson(Map<String, dynamic> json) =
      _$StreamingAudioSettingsImpl.fromJson;

  @override
  int? get bitrate;
  @override
  @JsonKey(ignore: true)
  _$$StreamingAudioSettingsImplCopyWith<_$StreamingAudioSettingsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StreamingLayout _$StreamingLayoutFromJson(Map<String, dynamic> json) {
  switch (json['preset']) {
    case 'default':
      return _DefaultLayout.fromJson(json);
    case 'single-participant':
      return _SingleParticipantLayout.fromJson(json);
    case 'active-participant':
      return _ActiveParticipantLayout.fromJson(json);
    case 'portrait':
      return _PortraitLayout.fromJson(json);
    case 'custom':
      return _CustomLayout.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'preset', 'StreamingLayout',
          'Invalid union type "${json['preset']}"!');
  }
}

/// @nodoc
mixin _$StreamingLayout {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamingLayoutCopyWith<$Res> {
  factory $StreamingLayoutCopyWith(
          StreamingLayout value, $Res Function(StreamingLayout) then) =
      _$StreamingLayoutCopyWithImpl<$Res, StreamingLayout>;
}

/// @nodoc
class _$StreamingLayoutCopyWithImpl<$Res, $Val extends StreamingLayout>
    implements $StreamingLayoutCopyWith<$Res> {
  _$StreamingLayoutCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DefaultLayoutImplCopyWith<$Res> {
  factory _$$DefaultLayoutImplCopyWith(
          _$DefaultLayoutImpl value, $Res Function(_$DefaultLayoutImpl) then) =
      __$$DefaultLayoutImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? maxCamStreams});
}

/// @nodoc
class __$$DefaultLayoutImplCopyWithImpl<$Res>
    extends _$StreamingLayoutCopyWithImpl<$Res, _$DefaultLayoutImpl>
    implements _$$DefaultLayoutImplCopyWith<$Res> {
  __$$DefaultLayoutImplCopyWithImpl(
      _$DefaultLayoutImpl _value, $Res Function(_$DefaultLayoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? maxCamStreams = freezed,
  }) {
    return _then(_$DefaultLayoutImpl(
      maxCamStreams: freezed == maxCamStreams
          ? _value.maxCamStreams
          : maxCamStreams // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DefaultLayoutImpl implements _DefaultLayout {
  const _$DefaultLayoutImpl({this.maxCamStreams, final String? $type})
      : $type = $type ?? 'default';

  factory _$DefaultLayoutImpl.fromJson(Map<String, dynamic> json) =>
      _$$DefaultLayoutImplFromJson(json);

  /// Specifies how many cameras to include in the grid.
  ///
  /// Default: 20, which is also the maximum number of cameras in a grid. This maximum may be increased in the future.
  @override
  final int? maxCamStreams;

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'StreamingLayout.defaultLayout(maxCamStreams: $maxCamStreams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DefaultLayoutImpl &&
            (identical(other.maxCamStreams, maxCamStreams) ||
                other.maxCamStreams == maxCamStreams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, maxCamStreams);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DefaultLayoutImplCopyWith<_$DefaultLayoutImpl> get copyWith =>
      __$$DefaultLayoutImplCopyWithImpl<_$DefaultLayoutImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) {
    return defaultLayout(maxCamStreams);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) {
    return defaultLayout?.call(maxCamStreams);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) {
    if (defaultLayout != null) {
      return defaultLayout(maxCamStreams);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) {
    return defaultLayout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) {
    return defaultLayout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) {
    if (defaultLayout != null) {
      return defaultLayout(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DefaultLayoutImplToJson(
      this,
    );
  }
}

abstract class _DefaultLayout implements StreamingLayout {
  const factory _DefaultLayout({final int? maxCamStreams}) =
      _$DefaultLayoutImpl;

  factory _DefaultLayout.fromJson(Map<String, dynamic> json) =
      _$DefaultLayoutImpl.fromJson;

  /// Specifies how many cameras to include in the grid.
  ///
  /// Default: 20, which is also the maximum number of cameras in a grid. This maximum may be increased in the future.
  int? get maxCamStreams;
  @JsonKey(ignore: true)
  _$$DefaultLayoutImplCopyWith<_$DefaultLayoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SingleParticipantLayoutImplCopyWith<$Res> {
  factory _$$SingleParticipantLayoutImplCopyWith(
          _$SingleParticipantLayoutImpl value,
          $Res Function(_$SingleParticipantLayoutImpl) then) =
      __$$SingleParticipantLayoutImplCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(name: 'sessionId') ParticipantId participant});

  $ParticipantIdCopyWith<$Res> get participant;
}

/// @nodoc
class __$$SingleParticipantLayoutImplCopyWithImpl<$Res>
    extends _$StreamingLayoutCopyWithImpl<$Res, _$SingleParticipantLayoutImpl>
    implements _$$SingleParticipantLayoutImplCopyWith<$Res> {
  __$$SingleParticipantLayoutImplCopyWithImpl(
      _$SingleParticipantLayoutImpl _value,
      $Res Function(_$SingleParticipantLayoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? participant = null,
  }) {
    return _then(_$SingleParticipantLayoutImpl(
      participant: null == participant
          ? _value.participant
          : participant // ignore: cast_nullable_to_non_nullable
              as ParticipantId,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ParticipantIdCopyWith<$Res> get participant {
    return $ParticipantIdCopyWith<$Res>(_value.participant, (value) {
      return _then(_value.copyWith(participant: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$SingleParticipantLayoutImpl implements _SingleParticipantLayout {
  const _$SingleParticipantLayoutImpl(
      {@JsonKey(name: 'sessionId') required this.participant,
      final String? $type})
      : $type = $type ?? 'single-participant';

  factory _$SingleParticipantLayoutImpl.fromJson(Map<String, dynamic> json) =>
      _$$SingleParticipantLayoutImplFromJson(json);

  @override
  @JsonKey(name: 'sessionId')
  final ParticipantId participant;

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'StreamingLayout.singleParticipant(participant: $participant)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SingleParticipantLayoutImpl &&
            (identical(other.participant, participant) ||
                other.participant == participant));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, participant);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SingleParticipantLayoutImplCopyWith<_$SingleParticipantLayoutImpl>
      get copyWith => __$$SingleParticipantLayoutImplCopyWithImpl<
          _$SingleParticipantLayoutImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) {
    return singleParticipant(participant);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) {
    return singleParticipant?.call(participant);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) {
    if (singleParticipant != null) {
      return singleParticipant(participant);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) {
    return singleParticipant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) {
    return singleParticipant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) {
    if (singleParticipant != null) {
      return singleParticipant(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SingleParticipantLayoutImplToJson(
      this,
    );
  }
}

abstract class _SingleParticipantLayout implements StreamingLayout {
  const factory _SingleParticipantLayout(
          {@JsonKey(name: 'sessionId')
          required final ParticipantId participant}) =
      _$SingleParticipantLayoutImpl;

  factory _SingleParticipantLayout.fromJson(Map<String, dynamic> json) =
      _$SingleParticipantLayoutImpl.fromJson;

  @JsonKey(name: 'sessionId')
  ParticipantId get participant;
  @JsonKey(ignore: true)
  _$$SingleParticipantLayoutImplCopyWith<_$SingleParticipantLayoutImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ActiveParticipantLayoutImplCopyWith<$Res> {
  factory _$$ActiveParticipantLayoutImplCopyWith(
          _$ActiveParticipantLayoutImpl value,
          $Res Function(_$ActiveParticipantLayoutImpl) then) =
      __$$ActiveParticipantLayoutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ActiveParticipantLayoutImplCopyWithImpl<$Res>
    extends _$StreamingLayoutCopyWithImpl<$Res, _$ActiveParticipantLayoutImpl>
    implements _$$ActiveParticipantLayoutImplCopyWith<$Res> {
  __$$ActiveParticipantLayoutImplCopyWithImpl(
      _$ActiveParticipantLayoutImpl _value,
      $Res Function(_$ActiveParticipantLayoutImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$ActiveParticipantLayoutImpl implements _ActiveParticipantLayout {
  const _$ActiveParticipantLayoutImpl({final String? $type})
      : $type = $type ?? 'active-participant';

  factory _$ActiveParticipantLayoutImpl.fromJson(Map<String, dynamic> json) =>
      _$$ActiveParticipantLayoutImplFromJson(json);

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'StreamingLayout.activeParticipant()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ActiveParticipantLayoutImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) {
    return activeParticipant();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) {
    return activeParticipant?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) {
    if (activeParticipant != null) {
      return activeParticipant();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) {
    return activeParticipant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) {
    return activeParticipant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) {
    if (activeParticipant != null) {
      return activeParticipant(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ActiveParticipantLayoutImplToJson(
      this,
    );
  }
}

abstract class _ActiveParticipantLayout implements StreamingLayout {
  const factory _ActiveParticipantLayout() = _$ActiveParticipantLayoutImpl;

  factory _ActiveParticipantLayout.fromJson(Map<String, dynamic> json) =
      _$ActiveParticipantLayoutImpl.fromJson;
}

/// @nodoc
abstract class _$$PortraitLayoutImplCopyWith<$Res> {
  factory _$$PortraitLayoutImplCopyWith(_$PortraitLayoutImpl value,
          $Res Function(_$PortraitLayoutImpl) then) =
      __$$PortraitLayoutImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PortraitVariant? variant, int? maxCamStreams});
}

/// @nodoc
class __$$PortraitLayoutImplCopyWithImpl<$Res>
    extends _$StreamingLayoutCopyWithImpl<$Res, _$PortraitLayoutImpl>
    implements _$$PortraitLayoutImplCopyWith<$Res> {
  __$$PortraitLayoutImplCopyWithImpl(
      _$PortraitLayoutImpl _value, $Res Function(_$PortraitLayoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? variant = freezed,
    Object? maxCamStreams = freezed,
  }) {
    return _then(_$PortraitLayoutImpl(
      variant: freezed == variant
          ? _value.variant
          : variant // ignore: cast_nullable_to_non_nullable
              as PortraitVariant?,
      maxCamStreams: freezed == maxCamStreams
          ? _value.maxCamStreams
          : maxCamStreams // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PortraitLayoutImpl implements _PortraitLayout {
  const _$PortraitLayoutImpl(
      {this.variant, this.maxCamStreams, final String? $type})
      : $type = $type ?? 'portrait';

  factory _$PortraitLayoutImpl.fromJson(Map<String, dynamic> json) =>
      _$$PortraitLayoutImplFromJson(json);

  @override
  final PortraitVariant? variant;
  @override
  final int? maxCamStreams;

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'StreamingLayout.portrait(variant: $variant, maxCamStreams: $maxCamStreams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PortraitLayoutImpl &&
            (identical(other.variant, variant) || other.variant == variant) &&
            (identical(other.maxCamStreams, maxCamStreams) ||
                other.maxCamStreams == maxCamStreams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, variant, maxCamStreams);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PortraitLayoutImplCopyWith<_$PortraitLayoutImpl> get copyWith =>
      __$$PortraitLayoutImplCopyWithImpl<_$PortraitLayoutImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) {
    return portrait(variant, maxCamStreams);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) {
    return portrait?.call(variant, maxCamStreams);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) {
    if (portrait != null) {
      return portrait(variant, maxCamStreams);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) {
    return portrait(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) {
    return portrait?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) {
    if (portrait != null) {
      return portrait(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PortraitLayoutImplToJson(
      this,
    );
  }
}

abstract class _PortraitLayout implements StreamingLayout {
  const factory _PortraitLayout(
      {final PortraitVariant? variant,
      final int? maxCamStreams}) = _$PortraitLayoutImpl;

  factory _PortraitLayout.fromJson(Map<String, dynamic> json) =
      _$PortraitLayoutImpl.fromJson;

  PortraitVariant? get variant;
  int? get maxCamStreams;
  @JsonKey(ignore: true)
  _$$PortraitLayoutImplCopyWith<_$PortraitLayoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CustomLayoutImplCopyWith<$Res> {
  factory _$$CustomLayoutImplCopyWith(
          _$CustomLayoutImpl value, $Res Function(_$CustomLayoutImpl) then) =
      __$$CustomLayoutImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String compositionId,
      Map<String, CompositionParamValue>? compositionParams,
      Map<String, String>? sessionAssets});
}

/// @nodoc
class __$$CustomLayoutImplCopyWithImpl<$Res>
    extends _$StreamingLayoutCopyWithImpl<$Res, _$CustomLayoutImpl>
    implements _$$CustomLayoutImplCopyWith<$Res> {
  __$$CustomLayoutImplCopyWithImpl(
      _$CustomLayoutImpl _value, $Res Function(_$CustomLayoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? compositionId = null,
    Object? compositionParams = freezed,
    Object? sessionAssets = freezed,
  }) {
    return _then(_$CustomLayoutImpl(
      compositionId: null == compositionId
          ? _value.compositionId
          : compositionId // ignore: cast_nullable_to_non_nullable
              as String,
      compositionParams: freezed == compositionParams
          ? _value._compositionParams
          : compositionParams // ignore: cast_nullable_to_non_nullable
              as Map<String, CompositionParamValue>?,
      sessionAssets: freezed == sessionAssets
          ? _value._sessionAssets
          : sessionAssets // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CustomLayoutImpl implements _CustomLayout {
  const _$CustomLayoutImpl(
      {required this.compositionId,
      final Map<String, CompositionParamValue>? compositionParams,
      final Map<String, String>? sessionAssets,
      final String? $type})
      : _compositionParams = compositionParams,
        _sessionAssets = sessionAssets,
        $type = $type ?? 'custom';

  factory _$CustomLayoutImpl.fromJson(Map<String, dynamic> json) =>
      _$$CustomLayoutImplFromJson(json);

  @override
  final String compositionId;
  final Map<String, CompositionParamValue>? _compositionParams;
  @override
  Map<String, CompositionParamValue>? get compositionParams {
    final value = _compositionParams;
    if (value == null) return null;
    if (_compositionParams is EqualUnmodifiableMapView)
      return _compositionParams;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, String>? _sessionAssets;
  @override
  Map<String, String>? get sessionAssets {
    final value = _sessionAssets;
    if (value == null) return null;
    if (_sessionAssets is EqualUnmodifiableMapView) return _sessionAssets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'StreamingLayout.custom(compositionId: $compositionId, compositionParams: $compositionParams, sessionAssets: $sessionAssets)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomLayoutImpl &&
            (identical(other.compositionId, compositionId) ||
                other.compositionId == compositionId) &&
            const DeepCollectionEquality()
                .equals(other._compositionParams, _compositionParams) &&
            const DeepCollectionEquality()
                .equals(other._sessionAssets, _sessionAssets));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      compositionId,
      const DeepCollectionEquality().hash(_compositionParams),
      const DeepCollectionEquality().hash(_sessionAssets));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomLayoutImplCopyWith<_$CustomLayoutImpl> get copyWith =>
      __$$CustomLayoutImplCopyWithImpl<_$CustomLayoutImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int? maxCamStreams) defaultLayout,
    required TResult Function(
            @JsonKey(name: 'sessionId') ParticipantId participant)
        singleParticipant,
    required TResult Function() activeParticipant,
    required TResult Function(PortraitVariant? variant, int? maxCamStreams)
        portrait,
    required TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)
        custom,
  }) {
    return custom(compositionId, compositionParams, sessionAssets);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int? maxCamStreams)? defaultLayout,
    TResult? Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult? Function()? activeParticipant,
    TResult? Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult? Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
  }) {
    return custom?.call(compositionId, compositionParams, sessionAssets);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int? maxCamStreams)? defaultLayout,
    TResult Function(@JsonKey(name: 'sessionId') ParticipantId participant)?
        singleParticipant,
    TResult Function()? activeParticipant,
    TResult Function(PortraitVariant? variant, int? maxCamStreams)? portrait,
    TResult Function(
            String compositionId,
            Map<String, CompositionParamValue>? compositionParams,
            Map<String, String>? sessionAssets)?
        custom,
    required TResult orElse(),
  }) {
    if (custom != null) {
      return custom(compositionId, compositionParams, sessionAssets);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DefaultLayout value) defaultLayout,
    required TResult Function(_SingleParticipantLayout value) singleParticipant,
    required TResult Function(_ActiveParticipantLayout value) activeParticipant,
    required TResult Function(_PortraitLayout value) portrait,
    required TResult Function(_CustomLayout value) custom,
  }) {
    return custom(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DefaultLayout value)? defaultLayout,
    TResult? Function(_SingleParticipantLayout value)? singleParticipant,
    TResult? Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult? Function(_PortraitLayout value)? portrait,
    TResult? Function(_CustomLayout value)? custom,
  }) {
    return custom?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DefaultLayout value)? defaultLayout,
    TResult Function(_SingleParticipantLayout value)? singleParticipant,
    TResult Function(_ActiveParticipantLayout value)? activeParticipant,
    TResult Function(_PortraitLayout value)? portrait,
    TResult Function(_CustomLayout value)? custom,
    required TResult orElse(),
  }) {
    if (custom != null) {
      return custom(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CustomLayoutImplToJson(
      this,
    );
  }
}

abstract class _CustomLayout implements StreamingLayout {
  const factory _CustomLayout(
      {required final String compositionId,
      final Map<String, CompositionParamValue>? compositionParams,
      final Map<String, String>? sessionAssets}) = _$CustomLayoutImpl;

  factory _CustomLayout.fromJson(Map<String, dynamic> json) =
      _$CustomLayoutImpl.fromJson;

  String get compositionId;
  Map<String, CompositionParamValue>? get compositionParams;
  Map<String, String>? get sessionAssets;
  @JsonKey(ignore: true)
  _$$CustomLayoutImplCopyWith<_$CustomLayoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CompositionParamValue {
  Object get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
    required TResult Function(double value) number,
    required TResult Function(bool value) boolean,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
    TResult? Function(double value)? number,
    TResult? Function(bool value)? boolean,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    TResult Function(double value)? number,
    TResult Function(bool value)? boolean,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CompositionStringParamValue value) string,
    required TResult Function(_CompositionNumberParamValue value) number,
    required TResult Function(_CompositionBooleanParamValue value) boolean,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CompositionStringParamValue value)? string,
    TResult? Function(_CompositionNumberParamValue value)? number,
    TResult? Function(_CompositionBooleanParamValue value)? boolean,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CompositionStringParamValue value)? string,
    TResult Function(_CompositionNumberParamValue value)? number,
    TResult Function(_CompositionBooleanParamValue value)? boolean,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompositionParamValueCopyWith<$Res> {
  factory $CompositionParamValueCopyWith(CompositionParamValue value,
          $Res Function(CompositionParamValue) then) =
      _$CompositionParamValueCopyWithImpl<$Res, CompositionParamValue>;
}

/// @nodoc
class _$CompositionParamValueCopyWithImpl<$Res,
        $Val extends CompositionParamValue>
    implements $CompositionParamValueCopyWith<$Res> {
  _$CompositionParamValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CompositionStringParamValueImplCopyWith<$Res> {
  factory _$$CompositionStringParamValueImplCopyWith(
          _$CompositionStringParamValueImpl value,
          $Res Function(_$CompositionStringParamValueImpl) then) =
      __$$CompositionStringParamValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$CompositionStringParamValueImplCopyWithImpl<$Res>
    extends _$CompositionParamValueCopyWithImpl<$Res,
        _$CompositionStringParamValueImpl>
    implements _$$CompositionStringParamValueImplCopyWith<$Res> {
  __$$CompositionStringParamValueImplCopyWithImpl(
      _$CompositionStringParamValueImpl _value,
      $Res Function(_$CompositionStringParamValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompositionStringParamValueImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CompositionStringParamValueImpl extends _CompositionStringParamValue {
  const _$CompositionStringParamValueImpl({required this.value}) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'CompositionParamValue.string(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompositionStringParamValueImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompositionStringParamValueImplCopyWith<_$CompositionStringParamValueImpl>
      get copyWith => __$$CompositionStringParamValueImplCopyWithImpl<
          _$CompositionStringParamValueImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
    required TResult Function(double value) number,
    required TResult Function(bool value) boolean,
  }) {
    return string(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
    TResult? Function(double value)? number,
    TResult? Function(bool value)? boolean,
  }) {
    return string?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    TResult Function(double value)? number,
    TResult Function(bool value)? boolean,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CompositionStringParamValue value) string,
    required TResult Function(_CompositionNumberParamValue value) number,
    required TResult Function(_CompositionBooleanParamValue value) boolean,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CompositionStringParamValue value)? string,
    TResult? Function(_CompositionNumberParamValue value)? number,
    TResult? Function(_CompositionBooleanParamValue value)? boolean,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CompositionStringParamValue value)? string,
    TResult Function(_CompositionNumberParamValue value)? number,
    TResult Function(_CompositionBooleanParamValue value)? boolean,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class _CompositionStringParamValue extends CompositionParamValue {
  const factory _CompositionStringParamValue({required final String value}) =
      _$CompositionStringParamValueImpl;
  const _CompositionStringParamValue._() : super._();

  @override
  String get value;
  @JsonKey(ignore: true)
  _$$CompositionStringParamValueImplCopyWith<_$CompositionStringParamValueImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompositionNumberParamValueImplCopyWith<$Res> {
  factory _$$CompositionNumberParamValueImplCopyWith(
          _$CompositionNumberParamValueImpl value,
          $Res Function(_$CompositionNumberParamValueImpl) then) =
      __$$CompositionNumberParamValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$CompositionNumberParamValueImplCopyWithImpl<$Res>
    extends _$CompositionParamValueCopyWithImpl<$Res,
        _$CompositionNumberParamValueImpl>
    implements _$$CompositionNumberParamValueImplCopyWith<$Res> {
  __$$CompositionNumberParamValueImplCopyWithImpl(
      _$CompositionNumberParamValueImpl _value,
      $Res Function(_$CompositionNumberParamValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompositionNumberParamValueImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$CompositionNumberParamValueImpl extends _CompositionNumberParamValue {
  const _$CompositionNumberParamValueImpl({required this.value}) : super._();

  @override
  final double value;

  @override
  String toString() {
    return 'CompositionParamValue.number(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompositionNumberParamValueImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompositionNumberParamValueImplCopyWith<_$CompositionNumberParamValueImpl>
      get copyWith => __$$CompositionNumberParamValueImplCopyWithImpl<
          _$CompositionNumberParamValueImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
    required TResult Function(double value) number,
    required TResult Function(bool value) boolean,
  }) {
    return number(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
    TResult? Function(double value)? number,
    TResult? Function(bool value)? boolean,
  }) {
    return number?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    TResult Function(double value)? number,
    TResult Function(bool value)? boolean,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CompositionStringParamValue value) string,
    required TResult Function(_CompositionNumberParamValue value) number,
    required TResult Function(_CompositionBooleanParamValue value) boolean,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CompositionStringParamValue value)? string,
    TResult? Function(_CompositionNumberParamValue value)? number,
    TResult? Function(_CompositionBooleanParamValue value)? boolean,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CompositionStringParamValue value)? string,
    TResult Function(_CompositionNumberParamValue value)? number,
    TResult Function(_CompositionBooleanParamValue value)? boolean,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }
}

abstract class _CompositionNumberParamValue extends CompositionParamValue {
  const factory _CompositionNumberParamValue({required final double value}) =
      _$CompositionNumberParamValueImpl;
  const _CompositionNumberParamValue._() : super._();

  @override
  double get value;
  @JsonKey(ignore: true)
  _$$CompositionNumberParamValueImplCopyWith<_$CompositionNumberParamValueImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CompositionBooleanParamValueImplCopyWith<$Res> {
  factory _$$CompositionBooleanParamValueImplCopyWith(
          _$CompositionBooleanParamValueImpl value,
          $Res Function(_$CompositionBooleanParamValueImpl) then) =
      __$$CompositionBooleanParamValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value});
}

/// @nodoc
class __$$CompositionBooleanParamValueImplCopyWithImpl<$Res>
    extends _$CompositionParamValueCopyWithImpl<$Res,
        _$CompositionBooleanParamValueImpl>
    implements _$$CompositionBooleanParamValueImplCopyWith<$Res> {
  __$$CompositionBooleanParamValueImplCopyWithImpl(
      _$CompositionBooleanParamValueImpl _value,
      $Res Function(_$CompositionBooleanParamValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$CompositionBooleanParamValueImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CompositionBooleanParamValueImpl extends _CompositionBooleanParamValue {
  const _$CompositionBooleanParamValueImpl({required this.value}) : super._();

  @override
  final bool value;

  @override
  String toString() {
    return 'CompositionParamValue.boolean(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompositionBooleanParamValueImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CompositionBooleanParamValueImplCopyWith<
          _$CompositionBooleanParamValueImpl>
      get copyWith => __$$CompositionBooleanParamValueImplCopyWithImpl<
          _$CompositionBooleanParamValueImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) string,
    required TResult Function(double value) number,
    required TResult Function(bool value) boolean,
  }) {
    return boolean(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? string,
    TResult? Function(double value)? number,
    TResult? Function(bool value)? boolean,
  }) {
    return boolean?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? string,
    TResult Function(double value)? number,
    TResult Function(bool value)? boolean,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CompositionStringParamValue value) string,
    required TResult Function(_CompositionNumberParamValue value) number,
    required TResult Function(_CompositionBooleanParamValue value) boolean,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CompositionStringParamValue value)? string,
    TResult? Function(_CompositionNumberParamValue value)? number,
    TResult? Function(_CompositionBooleanParamValue value)? boolean,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CompositionStringParamValue value)? string,
    TResult Function(_CompositionNumberParamValue value)? number,
    TResult Function(_CompositionBooleanParamValue value)? boolean,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class _CompositionBooleanParamValue extends CompositionParamValue {
  const factory _CompositionBooleanParamValue({required final bool value}) =
      _$CompositionBooleanParamValueImpl;
  const _CompositionBooleanParamValue._() : super._();

  @override
  bool get value;
  @JsonKey(ignore: true)
  _$$CompositionBooleanParamValueImplCopyWith<
          _$CompositionBooleanParamValueImpl>
      get copyWith => throw _privateConstructorUsedError;
}

LiveStreamEndpoints _$LiveStreamEndpointsFromJson(Map<String, dynamic> json) {
  switch (json['preset']) {
    case 'preconfigured':
      return PreconfiguredLiveStreamEndpoints.fromJson(json);
    case 'rtmpUrls':
      return RtmpUrlsLiveStreamEndpoints.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'preset', 'LiveStreamEndpoints',
          'Invalid union type "${json['preset']}"!');
  }
}

/// @nodoc
mixin _$LiveStreamEndpoints {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)
        preconfigured,
    required TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)
        rtmpUrls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult? Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PreconfiguredLiveStreamEndpoints value)
        preconfigured,
    required TResult Function(RtmpUrlsLiveStreamEndpoints value) rtmpUrls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult? Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiveStreamEndpointsCopyWith<$Res> {
  factory $LiveStreamEndpointsCopyWith(
          LiveStreamEndpoints value, $Res Function(LiveStreamEndpoints) then) =
      _$LiveStreamEndpointsCopyWithImpl<$Res, LiveStreamEndpoints>;
}

/// @nodoc
class _$LiveStreamEndpointsCopyWithImpl<$Res, $Val extends LiveStreamEndpoints>
    implements $LiveStreamEndpointsCopyWith<$Res> {
  _$LiveStreamEndpointsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PreconfiguredLiveStreamEndpointsImplCopyWith<$Res> {
  factory _$$PreconfiguredLiveStreamEndpointsImplCopyWith(
          _$PreconfiguredLiveStreamEndpointsImpl value,
          $Res Function(_$PreconfiguredLiveStreamEndpointsImpl) then) =
      __$$PreconfiguredLiveStreamEndpointsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints});
}

/// @nodoc
class __$$PreconfiguredLiveStreamEndpointsImplCopyWithImpl<$Res>
    extends _$LiveStreamEndpointsCopyWithImpl<$Res,
        _$PreconfiguredLiveStreamEndpointsImpl>
    implements _$$PreconfiguredLiveStreamEndpointsImplCopyWith<$Res> {
  __$$PreconfiguredLiveStreamEndpointsImplCopyWithImpl(
      _$PreconfiguredLiveStreamEndpointsImpl _value,
      $Res Function(_$PreconfiguredLiveStreamEndpointsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? endpoints = null,
  }) {
    return _then(_$PreconfiguredLiveStreamEndpointsImpl(
      endpoints: null == endpoints
          ? _value._endpoints
          : endpoints // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PreconfiguredLiveStreamEndpointsImpl
    extends PreconfiguredLiveStreamEndpoints {
  const _$PreconfiguredLiveStreamEndpointsImpl(
      {@JsonKey(name: 'preConfiguredEndpoints')
      required final List<String> endpoints,
      final String? $type})
      : _endpoints = endpoints,
        $type = $type ?? 'preconfigured',
        super._();

  factory _$PreconfiguredLiveStreamEndpointsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$PreconfiguredLiveStreamEndpointsImplFromJson(json);

  final List<String> _endpoints;
  @override
  @JsonKey(name: 'preConfiguredEndpoints')
  List<String> get endpoints {
    if (_endpoints is EqualUnmodifiableListView) return _endpoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_endpoints);
  }

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'LiveStreamEndpoints.preconfigured(endpoints: $endpoints)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PreconfiguredLiveStreamEndpointsImpl &&
            const DeepCollectionEquality()
                .equals(other._endpoints, _endpoints));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_endpoints));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PreconfiguredLiveStreamEndpointsImplCopyWith<
          _$PreconfiguredLiveStreamEndpointsImpl>
      get copyWith => __$$PreconfiguredLiveStreamEndpointsImplCopyWithImpl<
          _$PreconfiguredLiveStreamEndpointsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)
        preconfigured,
    required TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)
        rtmpUrls,
  }) {
    return preconfigured(endpoints);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult? Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
  }) {
    return preconfigured?.call(endpoints);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
    required TResult orElse(),
  }) {
    if (preconfigured != null) {
      return preconfigured(endpoints);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PreconfiguredLiveStreamEndpoints value)
        preconfigured,
    required TResult Function(RtmpUrlsLiveStreamEndpoints value) rtmpUrls,
  }) {
    return preconfigured(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult? Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
  }) {
    return preconfigured?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
    required TResult orElse(),
  }) {
    if (preconfigured != null) {
      return preconfigured(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PreconfiguredLiveStreamEndpointsImplToJson(
      this,
    );
  }
}

abstract class PreconfiguredLiveStreamEndpoints extends LiveStreamEndpoints {
  const factory PreconfiguredLiveStreamEndpoints(
          {@JsonKey(name: 'preConfiguredEndpoints')
          required final List<String> endpoints}) =
      _$PreconfiguredLiveStreamEndpointsImpl;
  const PreconfiguredLiveStreamEndpoints._() : super._();

  factory PreconfiguredLiveStreamEndpoints.fromJson(Map<String, dynamic> json) =
      _$PreconfiguredLiveStreamEndpointsImpl.fromJson;

  @JsonKey(name: 'preConfiguredEndpoints')
  List<String> get endpoints;
  @JsonKey(ignore: true)
  _$$PreconfiguredLiveStreamEndpointsImplCopyWith<
          _$PreconfiguredLiveStreamEndpointsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RtmpUrlsLiveStreamEndpointsImplCopyWith<$Res> {
  factory _$$RtmpUrlsLiveStreamEndpointsImplCopyWith(
          _$RtmpUrlsLiveStreamEndpointsImpl value,
          $Res Function(_$RtmpUrlsLiveStreamEndpointsImpl) then) =
      __$$RtmpUrlsLiveStreamEndpointsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({@JsonKey(name: 'rtmpUrls') List<Uri> urls});
}

/// @nodoc
class __$$RtmpUrlsLiveStreamEndpointsImplCopyWithImpl<$Res>
    extends _$LiveStreamEndpointsCopyWithImpl<$Res,
        _$RtmpUrlsLiveStreamEndpointsImpl>
    implements _$$RtmpUrlsLiveStreamEndpointsImplCopyWith<$Res> {
  __$$RtmpUrlsLiveStreamEndpointsImplCopyWithImpl(
      _$RtmpUrlsLiveStreamEndpointsImpl _value,
      $Res Function(_$RtmpUrlsLiveStreamEndpointsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? urls = null,
  }) {
    return _then(_$RtmpUrlsLiveStreamEndpointsImpl(
      urls: null == urls
          ? _value._urls
          : urls // ignore: cast_nullable_to_non_nullable
              as List<Uri>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RtmpUrlsLiveStreamEndpointsImpl extends RtmpUrlsLiveStreamEndpoints {
  const _$RtmpUrlsLiveStreamEndpointsImpl(
      {@JsonKey(name: 'rtmpUrls') required final List<Uri> urls,
      final String? $type})
      : _urls = urls,
        $type = $type ?? 'rtmpUrls',
        super._();

  factory _$RtmpUrlsLiveStreamEndpointsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$RtmpUrlsLiveStreamEndpointsImplFromJson(json);

  final List<Uri> _urls;
  @override
  @JsonKey(name: 'rtmpUrls')
  List<Uri> get urls {
    if (_urls is EqualUnmodifiableListView) return _urls;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_urls);
  }

  @JsonKey(name: 'preset')
  final String $type;

  @override
  String toString() {
    return 'LiveStreamEndpoints.rtmpUrls(urls: $urls)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RtmpUrlsLiveStreamEndpointsImpl &&
            const DeepCollectionEquality().equals(other._urls, _urls));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_urls));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RtmpUrlsLiveStreamEndpointsImplCopyWith<_$RtmpUrlsLiveStreamEndpointsImpl>
      get copyWith => __$$RtmpUrlsLiveStreamEndpointsImplCopyWithImpl<
          _$RtmpUrlsLiveStreamEndpointsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)
        preconfigured,
    required TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)
        rtmpUrls,
  }) {
    return rtmpUrls(urls);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult? Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
  }) {
    return rtmpUrls?.call(urls);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @JsonKey(name: 'preConfiguredEndpoints') List<String> endpoints)?
        preconfigured,
    TResult Function(@JsonKey(name: 'rtmpUrls') List<Uri> urls)? rtmpUrls,
    required TResult orElse(),
  }) {
    if (rtmpUrls != null) {
      return rtmpUrls(urls);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PreconfiguredLiveStreamEndpoints value)
        preconfigured,
    required TResult Function(RtmpUrlsLiveStreamEndpoints value) rtmpUrls,
  }) {
    return rtmpUrls(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult? Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
  }) {
    return rtmpUrls?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PreconfiguredLiveStreamEndpoints value)? preconfigured,
    TResult Function(RtmpUrlsLiveStreamEndpoints value)? rtmpUrls,
    required TResult orElse(),
  }) {
    if (rtmpUrls != null) {
      return rtmpUrls(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RtmpUrlsLiveStreamEndpointsImplToJson(
      this,
    );
  }
}

abstract class RtmpUrlsLiveStreamEndpoints extends LiveStreamEndpoints {
  const factory RtmpUrlsLiveStreamEndpoints(
          {@JsonKey(name: 'rtmpUrls') required final List<Uri> urls}) =
      _$RtmpUrlsLiveStreamEndpointsImpl;
  const RtmpUrlsLiveStreamEndpoints._() : super._();

  factory RtmpUrlsLiveStreamEndpoints.fromJson(Map<String, dynamic> json) =
      _$RtmpUrlsLiveStreamEndpointsImpl.fromJson;

  @JsonKey(name: 'rtmpUrls')
  List<Uri> get urls;
  @JsonKey(ignore: true)
  _$$RtmpUrlsLiveStreamEndpointsImplCopyWith<_$RtmpUrlsLiveStreamEndpointsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RecordingStatus _$RecordingStatusFromJson(Map<String, dynamic> json) {
  return _RecordingStatus.fromJson(json);
}

/// @nodoc
mixin _$RecordingStatus {
  /// The id of the recording file.
  RecordingId? get recordingId => throw _privateConstructorUsedError;

  /// The participant who started the recording.
  ParticipantId? get startedBy => throw _privateConstructorUsedError;

  /// Specifies how the participants' videos are laid out in the stream.
  StreamingLayout? get layout => throw _privateConstructorUsedError;

  /// The identifier of the streaming instance.
  StreamId get streamId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RecordingStatusCopyWith<RecordingStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecordingStatusCopyWith<$Res> {
  factory $RecordingStatusCopyWith(
          RecordingStatus value, $Res Function(RecordingStatus) then) =
      _$RecordingStatusCopyWithImpl<$Res, RecordingStatus>;
  @useResult
  $Res call(
      {RecordingId? recordingId,
      ParticipantId? startedBy,
      StreamingLayout? layout,
      StreamId streamId});

  $RecordingIdCopyWith<$Res>? get recordingId;
  $ParticipantIdCopyWith<$Res>? get startedBy;
  $StreamingLayoutCopyWith<$Res>? get layout;
  $StreamIdCopyWith<$Res> get streamId;
}

/// @nodoc
class _$RecordingStatusCopyWithImpl<$Res, $Val extends RecordingStatus>
    implements $RecordingStatusCopyWith<$Res> {
  _$RecordingStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? recordingId = freezed,
    Object? startedBy = freezed,
    Object? layout = freezed,
    Object? streamId = null,
  }) {
    return _then(_value.copyWith(
      recordingId: freezed == recordingId
          ? _value.recordingId
          : recordingId // ignore: cast_nullable_to_non_nullable
              as RecordingId?,
      startedBy: freezed == startedBy
          ? _value.startedBy
          : startedBy // ignore: cast_nullable_to_non_nullable
              as ParticipantId?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      streamId: null == streamId
          ? _value.streamId
          : streamId // ignore: cast_nullable_to_non_nullable
              as StreamId,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RecordingIdCopyWith<$Res>? get recordingId {
    if (_value.recordingId == null) {
      return null;
    }

    return $RecordingIdCopyWith<$Res>(_value.recordingId!, (value) {
      return _then(_value.copyWith(recordingId: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ParticipantIdCopyWith<$Res>? get startedBy {
    if (_value.startedBy == null) {
      return null;
    }

    return $ParticipantIdCopyWith<$Res>(_value.startedBy!, (value) {
      return _then(_value.copyWith(startedBy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingLayoutCopyWith<$Res>? get layout {
    if (_value.layout == null) {
      return null;
    }

    return $StreamingLayoutCopyWith<$Res>(_value.layout!, (value) {
      return _then(_value.copyWith(layout: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamIdCopyWith<$Res> get streamId {
    return $StreamIdCopyWith<$Res>(_value.streamId, (value) {
      return _then(_value.copyWith(streamId: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RecordingStatusImplCopyWith<$Res>
    implements $RecordingStatusCopyWith<$Res> {
  factory _$$RecordingStatusImplCopyWith(_$RecordingStatusImpl value,
          $Res Function(_$RecordingStatusImpl) then) =
      __$$RecordingStatusImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RecordingId? recordingId,
      ParticipantId? startedBy,
      StreamingLayout? layout,
      StreamId streamId});

  @override
  $RecordingIdCopyWith<$Res>? get recordingId;
  @override
  $ParticipantIdCopyWith<$Res>? get startedBy;
  @override
  $StreamingLayoutCopyWith<$Res>? get layout;
  @override
  $StreamIdCopyWith<$Res> get streamId;
}

/// @nodoc
class __$$RecordingStatusImplCopyWithImpl<$Res>
    extends _$RecordingStatusCopyWithImpl<$Res, _$RecordingStatusImpl>
    implements _$$RecordingStatusImplCopyWith<$Res> {
  __$$RecordingStatusImplCopyWithImpl(
      _$RecordingStatusImpl _value, $Res Function(_$RecordingStatusImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? recordingId = freezed,
    Object? startedBy = freezed,
    Object? layout = freezed,
    Object? streamId = null,
  }) {
    return _then(_$RecordingStatusImpl(
      recordingId: freezed == recordingId
          ? _value.recordingId
          : recordingId // ignore: cast_nullable_to_non_nullable
              as RecordingId?,
      startedBy: freezed == startedBy
          ? _value.startedBy
          : startedBy // ignore: cast_nullable_to_non_nullable
              as ParticipantId?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      streamId: null == streamId
          ? _value.streamId
          : streamId // ignore: cast_nullable_to_non_nullable
              as StreamId,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RecordingStatusImpl extends _RecordingStatus {
  const _$RecordingStatusImpl(
      {this.recordingId, this.startedBy, this.layout, required this.streamId})
      : super._();

  factory _$RecordingStatusImpl.fromJson(Map<String, dynamic> json) =>
      _$$RecordingStatusImplFromJson(json);

  /// The id of the recording file.
  @override
  final RecordingId? recordingId;

  /// The participant who started the recording.
  @override
  final ParticipantId? startedBy;

  /// Specifies how the participants' videos are laid out in the stream.
  @override
  final StreamingLayout? layout;

  /// The identifier of the streaming instance.
  @override
  final StreamId streamId;

  @override
  String toString() {
    return 'RecordingStatus(recordingId: $recordingId, startedBy: $startedBy, layout: $layout, streamId: $streamId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordingStatusImpl &&
            (identical(other.recordingId, recordingId) ||
                other.recordingId == recordingId) &&
            (identical(other.startedBy, startedBy) ||
                other.startedBy == startedBy) &&
            (identical(other.layout, layout) || other.layout == layout) &&
            (identical(other.streamId, streamId) ||
                other.streamId == streamId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, recordingId, startedBy, layout, streamId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordingStatusImplCopyWith<_$RecordingStatusImpl> get copyWith =>
      __$$RecordingStatusImplCopyWithImpl<_$RecordingStatusImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RecordingStatusImplToJson(
      this,
    );
  }
}

abstract class _RecordingStatus extends RecordingStatus {
  const factory _RecordingStatus(
      {final RecordingId? recordingId,
      final ParticipantId? startedBy,
      final StreamingLayout? layout,
      required final StreamId streamId}) = _$RecordingStatusImpl;
  const _RecordingStatus._() : super._();

  factory _RecordingStatus.fromJson(Map<String, dynamic> json) =
      _$RecordingStatusImpl.fromJson;

  @override

  /// The id of the recording file.
  RecordingId? get recordingId;
  @override

  /// The participant who started the recording.
  ParticipantId? get startedBy;
  @override

  /// Specifies how the participants' videos are laid out in the stream.
  StreamingLayout? get layout;
  @override

  /// The identifier of the streaming instance.
  StreamId get streamId;
  @override
  @JsonKey(ignore: true)
  _$$RecordingStatusImplCopyWith<_$RecordingStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LiveStreamStatus _$LiveStreamStatusFromJson(Map<String, dynamic> json) {
  return _LiveStreamStatus.fromJson(json);
}

/// @nodoc
mixin _$LiveStreamStatus {
  /// The participant who started the stream.
  ParticipantId? get startedBy => throw _privateConstructorUsedError;

  /// Specifies how the participants' videos are laid out in the stream.
  StreamingLayout? get layout => throw _privateConstructorUsedError;

  /// The identifier of the live streaming instance.
  StreamId get streamId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LiveStreamStatusCopyWith<LiveStreamStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiveStreamStatusCopyWith<$Res> {
  factory $LiveStreamStatusCopyWith(
          LiveStreamStatus value, $Res Function(LiveStreamStatus) then) =
      _$LiveStreamStatusCopyWithImpl<$Res, LiveStreamStatus>;
  @useResult
  $Res call(
      {ParticipantId? startedBy, StreamingLayout? layout, StreamId streamId});

  $ParticipantIdCopyWith<$Res>? get startedBy;
  $StreamingLayoutCopyWith<$Res>? get layout;
  $StreamIdCopyWith<$Res> get streamId;
}

/// @nodoc
class _$LiveStreamStatusCopyWithImpl<$Res, $Val extends LiveStreamStatus>
    implements $LiveStreamStatusCopyWith<$Res> {
  _$LiveStreamStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? startedBy = freezed,
    Object? layout = freezed,
    Object? streamId = null,
  }) {
    return _then(_value.copyWith(
      startedBy: freezed == startedBy
          ? _value.startedBy
          : startedBy // ignore: cast_nullable_to_non_nullable
              as ParticipantId?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      streamId: null == streamId
          ? _value.streamId
          : streamId // ignore: cast_nullable_to_non_nullable
              as StreamId,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ParticipantIdCopyWith<$Res>? get startedBy {
    if (_value.startedBy == null) {
      return null;
    }

    return $ParticipantIdCopyWith<$Res>(_value.startedBy!, (value) {
      return _then(_value.copyWith(startedBy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamingLayoutCopyWith<$Res>? get layout {
    if (_value.layout == null) {
      return null;
    }

    return $StreamingLayoutCopyWith<$Res>(_value.layout!, (value) {
      return _then(_value.copyWith(layout: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StreamIdCopyWith<$Res> get streamId {
    return $StreamIdCopyWith<$Res>(_value.streamId, (value) {
      return _then(_value.copyWith(streamId: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LiveStreamStatusImplCopyWith<$Res>
    implements $LiveStreamStatusCopyWith<$Res> {
  factory _$$LiveStreamStatusImplCopyWith(_$LiveStreamStatusImpl value,
          $Res Function(_$LiveStreamStatusImpl) then) =
      __$$LiveStreamStatusImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ParticipantId? startedBy, StreamingLayout? layout, StreamId streamId});

  @override
  $ParticipantIdCopyWith<$Res>? get startedBy;
  @override
  $StreamingLayoutCopyWith<$Res>? get layout;
  @override
  $StreamIdCopyWith<$Res> get streamId;
}

/// @nodoc
class __$$LiveStreamStatusImplCopyWithImpl<$Res>
    extends _$LiveStreamStatusCopyWithImpl<$Res, _$LiveStreamStatusImpl>
    implements _$$LiveStreamStatusImplCopyWith<$Res> {
  __$$LiveStreamStatusImplCopyWithImpl(_$LiveStreamStatusImpl _value,
      $Res Function(_$LiveStreamStatusImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? startedBy = freezed,
    Object? layout = freezed,
    Object? streamId = null,
  }) {
    return _then(_$LiveStreamStatusImpl(
      startedBy: freezed == startedBy
          ? _value.startedBy
          : startedBy // ignore: cast_nullable_to_non_nullable
              as ParticipantId?,
      layout: freezed == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as StreamingLayout?,
      streamId: null == streamId
          ? _value.streamId
          : streamId // ignore: cast_nullable_to_non_nullable
              as StreamId,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LiveStreamStatusImpl implements _LiveStreamStatus {
  const _$LiveStreamStatusImpl(
      {this.startedBy, this.layout, required this.streamId});

  factory _$LiveStreamStatusImpl.fromJson(Map<String, dynamic> json) =>
      _$$LiveStreamStatusImplFromJson(json);

  /// The participant who started the stream.
  @override
  final ParticipantId? startedBy;

  /// Specifies how the participants' videos are laid out in the stream.
  @override
  final StreamingLayout? layout;

  /// The identifier of the live streaming instance.
  @override
  final StreamId streamId;

  @override
  String toString() {
    return 'LiveStreamStatus(startedBy: $startedBy, layout: $layout, streamId: $streamId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiveStreamStatusImpl &&
            (identical(other.startedBy, startedBy) ||
                other.startedBy == startedBy) &&
            (identical(other.layout, layout) || other.layout == layout) &&
            (identical(other.streamId, streamId) ||
                other.streamId == streamId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, startedBy, layout, streamId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiveStreamStatusImplCopyWith<_$LiveStreamStatusImpl> get copyWith =>
      __$$LiveStreamStatusImplCopyWithImpl<_$LiveStreamStatusImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LiveStreamStatusImplToJson(
      this,
    );
  }
}

abstract class _LiveStreamStatus implements LiveStreamStatus {
  const factory _LiveStreamStatus(
      {final ParticipantId? startedBy,
      final StreamingLayout? layout,
      required final StreamId streamId}) = _$LiveStreamStatusImpl;

  factory _LiveStreamStatus.fromJson(Map<String, dynamic> json) =
      _$LiveStreamStatusImpl.fromJson;

  @override

  /// The participant who started the stream.
  ParticipantId? get startedBy;
  @override

  /// Specifies how the participants' videos are laid out in the stream.
  StreamingLayout? get layout;
  @override

  /// The identifier of the live streaming instance.
  StreamId get streamId;
  @override
  @JsonKey(ignore: true)
  _$$LiveStreamStatusImplCopyWith<_$LiveStreamStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
